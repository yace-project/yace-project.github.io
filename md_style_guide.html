<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>𝔜𝔄ℭ𝔈: 𝔜𝔄ℭ𝔈 Style Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">𝔜𝔄ℭ𝔈
   &#160;<span id="projectnumber">0.0.0.0</span>
   </div>
   <div id="projectbrief">Yet Another CPU Emulator</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">𝔜𝔄ℭ𝔈 Style Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Imported_Entities">Imported standard entities</a></li>
<li class="level1"><a href="#Heder_Files">Header files</a></li>
<li class="level1"><a href="#autotoc_md0">Initialization # (#Initialization)</a></li>
<li class="level1"><a href="#autotoc_md1">Trailing Return Type Syntax # (#Trailing_Return)</a></li>
<li class="level1"><a href="#autotoc_md3">Implicit conversions.</a></li>
<li class="level1"><a href="#Naming">Naming</a><ul><li class="level2"><a href="#The_define_Guard">The define Guard</a></li>
<li class="level2"><a href="#File_Names">File Names</a></li>
<li class="level2"><a href="#Type_Names">Type Names</a></li>
<li class="level2"><a href="#Variable_Names">Variable Names</a><ul><li class="level3"><a href="#Common_Variable_Names">Common Variable Names</a></li>
<li class="level3"><a href="#Struct_Data_Member_Names">Struct Data Members Names</a></li>
<li class="level3"><a href="#Class_Data_Members_Names">Class Data Members Names</a></li>
</ul>
</li>
<li class="level2"><a href="#Constant_Names">Constant Names</a></li>
<li class="level2"><a href="#Function_Names">Function Names</a></li>
<li class="level2"><a href="#Template_Names">Template Names</a></li>
<li class="level2"><a href="#Namespace_Names">Namespace Names</a></li>
<li class="level2"><a href="#Enumerator_Names">Enumerator Names</a></li>
<li class="level2"><a href="#Macro_Names">Macro Names</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>Our style guide is based on <a href="https://google.github.io/styleguide/cppguide.html">Google Style Guide</a> with certain differences. Most of them are related to the fact that we are developing modern C++17-based codebase from scratch while Google have to deal with the codebase which is quarter-century old. We are also developing code which may be used as part of other projects while Google have full control over it's codebase.</p>
<p>The biggest difference which is immediately seen is related to naming. While Google uses <a href="https://en.wikipedia.org/wiki/Camel_case">Camel Case</a> (for types and class names) and <a href="https://en.wikipedia.org/wiki/SCREAMING_SNAKE_CASE">SCREAMING SNAKE CASE</a> (for macro defnitions) 𝔜𝔄ℭ𝔈 uses <a href="https://en.wikipedia.org/wiki/Snake_case">snake_case</a> almost exclusively (the only exception is <a href="#The_define_Guard">a header guard</a>).</p>
<h1><a class="anchor" id="Imported_Entities"></a>
Imported standard entities</h1>
<p>𝔜𝔄ℭ𝔈 is designed to be build with C++17 compilers (with C++20 designated initializers are <a href="https://google.github.io/styleguide/cppguide.html#Designated_initializers">the Google C++ Style Guide</a> allows) but it tries to make core ready for eventual switch to C++20. To make that easier we import certain types from <code>std</code> namespace conditionally.</p>
<p>Use these types and templates instead of their <code>std</code> counterpart:</p><ul>
<li><code>𝐜𝐡𝐚𝐫</code>: it's <code>char8_t</code> if that type is available and <code>unsigned</code> <code>char</code> otherwise.</li>
<li><code>𝐛𝐲𝐭𝐞</code>: it's <code>std::byte</code> if that type is available and <code>unsigned</code> <code>char</code> otherwise.</li>
<li><code>𝐬𝐭𝐫𝐢𝐧𝐠</code>: it's <code>std::u8string</code> if it's available and <code>std::basic_string&lt;𝐜𝐡𝐚𝐫&gt;</code> otherwise.</li>
<li><code>𝐬𝐭𝐫𝐢𝐧𝐠_𝐯𝐢𝐞𝐰</code>: it's <code>std::u8string_view</code> if it's available and <code>std::basic_string_view&lt;𝐜𝐡𝐚𝐫&gt;</code> otherwise.</li>
<li><code>𝒓𝒆𝒎𝒐𝒗𝒆_𝒄𝒗𝒓𝒆𝒇</code>: it's <code>std::remove_cvref_t&lt;𝓣&gt;</code> if it's available and <code>std::decay_t&lt;𝓣&gt;</code> otherwise.</li>
</ul>
<p>The following types are just imported for brevity <code>𝐛𝐨𝐨𝐥</code>, <code>𝐢𝐧𝐭₈</code>, <code>𝐮𝐢𝐧𝐭₈</code>, <code>𝐢𝐧𝐭₁₆</code>, <code>𝐮𝐢𝐧𝐭₁₆</code>, <code>𝐢𝐧𝐭₃₂</code>, <code>𝐮𝐢𝐧𝐭₃₂</code>, <code>𝐢𝐧𝐭₆₄</code>, <code>𝐮𝐢𝐧𝐭₆₄</code>, <code>𝐢𝐧𝐭ₘₐₓ</code>, <code>𝐮𝐢𝐧𝐭ₘₐₓ</code>, <code>𝐬𝐢𝐳𝐞</code>, <code>𝐩𝐭𝐫𝐝𝐢𝐟𝐟</code>, <code>𝐧𝐮𝐥𝐥𝐩𝐭𝐫</code>. They are usually used instead of their <code>std</code> counterpart, but that's not a strict requirement.</p>
<h1><a class="anchor" id="Heder_Files"></a>
Header files</h1>
<p>In general, every <code>.cc</code> file should have an associated <code>.h</code> file. There are some common exceptions, such as unit tests and small <code>.cc</code> files containing just a <code>main()</code> function.</p>
<p>If all entities in the <code>.cc</code> file are compinent-internal then said file is placed into the component directory and is included without <code>yace/</code><em><code>component</code></em> prefix. If all entities are exported then file goes into <code>include</code>/<code>yace</code>/<em><code>component</code></em> folder and are included from <code>include</code>/<code>yace</code>/<em><code>component</code></em><code>.h</code> file. If there are both exported and not exported entities then there would be two <code>.h</code> file for a given <code>.cc</code> files.</p>
<p>Files inside a component should use fine-grained headers but other components should just include <code>yace</code>/<em><code>component</code></em><code>.h</code> file. This file should just include all public files provided by the component. If a component exports so many entities that such file becomes unacceptably large then this component should be split into two (or more) subcomponents.</p>
<p>Except for this and the “main” per-component <code>.h</code> file follow rules of <a href="https://google.github.io/styleguide/cppguide.html#Header_Files">the Google C++ Style Guide</a>.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Initialization # (#Initialization)</h1>
<p>Originlly Google C++ Style Guide recommended not to do any work in constructors — but provide <code>Init()</code> function instead. That approach is forbidden in 𝔜𝔄ℭ𝔈. If you really need a constructor which may signal error without exceptions — use an output flag.</p>
<p>This way even if exceptions are disable you may never have objects which are “half-ready”. You may have “zombie” objects (which are no usabled except for call to destructor), but these are easier to construct and deal with.</p>
<p>Note: you should <b>only</b> handle errors in that way which are produced by some ourside state. If you want to check condition which may only be invalid in case of programming error — use <code>assert</code> instead of output flag!</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Trailing Return Type Syntax # (#Trailing_Return)</h1>
<p>Don't use old C style declarations for functions. New syntax with trailing return type is preferable because it's easier to parse and while it's somewhat longer this is mitigated in 𝔜𝔄ℭ𝔈 by 132 characters line length.</p>
<hr  />
<p> rough</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Implicit conversions.</h1>
<p>Please read <a href="https://abseil.io/tips/142">totw142</a> - we don't ban all implicit constructors.</p>
<hr  />
<h1><a class="anchor" id="Naming"></a>
Naming</h1>
<p>𝔜𝔄ℭ𝔈 is a modern codebase and uses the fact that all C++17 compilers have full Unicode support. The only outlier is GCC: while most C++17 compilers <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlICsupVs1qhkAUgBMAISnTSAZ0ztkBPHUqZa6AMKpWAVwC2tEJIDspLegAyeWpgByxgEaZiggA6oFhdbT1DEzNLb181OjsHZyM3D05FZUxVfwYCZmICQONTC0SVCNo0jIIop1d3QQV0zOzgvOqSspi4rgBKRVQDYmQOAHIXVH0AanEAMQAGcQBOMfEADgA2Be5xqdmFgFZxaQARNZm5%2Be3peYON453Jc6OT7ButnYBmB8vpblGn3eGCYgNMcRPaR9DqsEB9TZ9UimPoTKGocE6ORyYYKLo9TCjSRPThQgjguFtDoAay4EwmQnB3ChRhAmwpMLhpARfShChAFPxsJBpDgsBgiBQqCMnjw7DIFAgaBFYsqyGEonpFKoYoI7nZEBcBKhLnsGQAnuDcaRpUYtAQAPK0ViG7mkLBGETAdhGqH4YjJNQAN0w7LtmAAHskDGrXeR6Mow6w8C5iAa9Fgw788LS%2BriOjR6Ew2BwePwzEInShkTIhDH2ZAOqhPIU/QBaC2SYZ16roQG7CQyOSccxspIpDQQax1UwJazNCrxUhhPx0EdeHyz2gT2KVBJKAqpGpZfQ5Kr9wrFTIr1rr7fzs9NezlVfxDpo7q9dqUiFQxnw8EBpZ1xYfeVO4ZNgAOgmEDhggXBCBILEcVIYY9BlcUYMkNp4JLYFSC5QkOgQTBmCwDwIBJEAnieIDSIoyiqMWF9qVIWl6WhbVmXBNkOUw7UOj5QVpVFcVyEoXjZQ8L1kE8TwAH0vU4aYJJ4CSA1/UgVVYNViA1LU7V1WgDTDU1zStG1mIdJ0XTTN08A9FIfT9JlA2DUNzPDNUwSc6NY3jDB%2BmNZNU3TZS6EYFgXTzAQEgVMR0LLFwKyI5ka38P0AHpG2GJKQyoOt5jS1tiy7GQez7TdB2HXdgjHbQTzXadF0KC8avCfwqqnDdPS3Ep6tagcim3ZqqnPMrR0UXrrxaNd73RJ9OFBcFISYu0WUUj4jAUUThmk6YgJ4cDIKIYgYISeDhT49wDtQpF8owrCQRwvCCMoYjSPIqiXtImjXLo98WNZRR2OuriBQgJAhP4yUQcqPBkGQHtlNVdVKE0pltN0pz9PoQzbSZEzRDM413TamzmPs5AQ28qF7BcqMYzjYh9QTMnMOIFNXQzQLsxC3gBCeQtRDy2RS3c2KqwSuh61SlsCDbL5O356RCvyNqSu0erx1GycF0audBo1pc%2BvXA92tqbX9eKnqr2idXLyNoIhsaY81dvZ8HwxZ9XLmr7Fu/X9hkh5Bhh7ECwIg/A9oOuCEJO/apFI870LxTjHrI17Xtot9mJZNjOQTl9JBpOkGXT1iOO5IkXyeNOFqL/6Oh9dT/BAbggA%3D%3D%3D">have full support for Unicode</a> starting from version where they got support for C++17 GCC is very much an outlier: you need <a href="https://gcc.gnu.org/gcc-10/changes.html">GCC 10+</a> for <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> support. Normally we would try to avoid using such a brand-new feature, Unicode support in GCC is, actually, quite old and robust: it's supported <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlICsupVs1qhkAUgBMAISnTSAZ0ztkBPHUqZa6AMKpWAVwC2tEAA5eW9ABk8tTADljAI0zFBAB1QLC62nsMTc14vHzU6W3snI1d3TkVlTFU/BgJmYgIA41MLBJVw2lT0gkjHFzdBBTSMrKDcquLS6NiuAEpFVANiZA4AcmdUfQBqcQBWHQBVAAYZzipOCzHJmam5zgB2dCXp2fn1s22VtfXJQ92NzDPVvYBmK%2BPuEZuAESGCYgNLm%2Ble9tYQXqjXqkUy9KbA1AAnRyORDBSdbqYEaSG6cYEEAHg1rtADWXBmQgB3GBRhAoymIMxEIBwIUIApGLBv1IcFgMEQKFQRg8eHYZAoEDQ3N5FWQwlE5IpVF5BDcdIgzippGcdnSAE8AWjSEKjFoCAB5WisDVM0hYIwiYDsTXA/DEJJqABumDppswAA8kgZZTbyPRlL7WHhnMR1XosL73nhSb00e0aPQmGwODx%2BCBJEJLSgYTIhMG6ZB2qgPAVXQBafWSIZlqpbF4SGRyDa0xLJDQQKy1UzxKxNcpxUihXx0LuebzD2h9mIVeJKfIpaqZfTZSqtgpFDJTlqzxejneNOxladxdrwro9NqEwHA0Hg0iQ3ruswANjLz8eYstQ1GADopn%2BhggXBCBIZFUVIIY9GFPkwMkVpIJzH5SEZLF2gQTBmCwdwIFxdNRivYlSFJclKVNB9aXpZCqXaVkOSFHk%2BXISh6JFdxgFGTgpRlOVKEVU0VVodVfR1PVDWNJVzUta1Y1tPB7WSZ1XTvD0vR9GS/Vlf51KDEMwwwPotSjGM41IBNGBYa1UwEeJxTERC82cAscPvEs/HLStq1rcR60Q5s8gdPxNG0PdSF7Q9mhnQdxwKEKhwKLdIrnAK6A3JdAm7fy20KRcEoHBoamXIJ903cL%2B0vM9EUvLSgVIu8HyfV93yGYBkGQb8f04QDgKIYgwPiSCuQYtw%2Bvg6FGxkdFqLQjCsMoXDJHwrTCNvalegohlqJZdkICQFjGIFPaKkdZAPA8AB9R1OAATjOngzvdd9TO44h5T4u8BKE9SRPoMSTTvSTRGkrU7QCxSlRU5BvQM4E7E0wNg1DYg1XDaHkOIaMbXjOhzOTLheAEG5M1EbNxvkHSnKLVy6FdAB6Dyae9KgyzMIYadrEnZBkPykqyoLdEKjKwqiMr4jivxYuivxctXecUt3AWZeS7KD2F49Knl9L1ZVo9t1PBEL04P4ARqlb7wBB7HiMBRjqGS6ro6x4gPwHq%2BogqCht6qQbhuUbEMmplsVIPFJG4H8rvDiPI8j58CJvJVyMUSiUOZWids5aC3CYwVBtYkA8FajYntYWUXt4pUPqR4SuV1H6jT%2B21MAtQHUZBhSXXBz1IbUrVYYDbSEb0iN1KMzHTOxpNLPxkBeFsjm5AcimXNLAEKyrGsCDrZ4G056RubXQKO2ChWe20aXRclkdj6isIpdKtXZ33uXihCnn1xyu/t0UDWV2KkoP5nPW54UxG2vLVVaDU3yPHzm1DYf4AJOxAp7FE/V3asTAtwX2pN/aoSDnhWOYCzZrUThtAOIDJAkjJBSU2Cdk6By0jcOOZEaRUVIaQZ0L1ArcCAA%3D">starting from GCC 5</a> — but you need to use escape sequences (which could be produced with a simple preprocessor if needed).</p>
<p>Mathematicians have used differenly-styled letters for different entities long before C++ was ever dreamed of and for their needs Unicode included <a href="https://en.wikipedia.org/wiki/Mathematical_Alphanumeric_Symbols#Latin_letters">wast repertoire</a> of letters. We are repurposing them to help us distinguish different entities of C++.</p>
<h2><a class="anchor" id="The_define_Guard"></a>
The define Guard</h2>
<p>All header files should have #define guards to prevent multiple inclusion. The format of the symbol name should be <code>“𝔓ℜ𝔒𝔍𝔈ℭ𝔗”_“𝔓𝔄𝔗ℌ”_“𝔉ℑ𝔏𝔈”_ℌ</code>. Note: we are using ALL_CAPS — and not just ALL_CAPS, but <a href="https://en.wikipedia.org/wiki/Fraktur">fraktur-style</a> <a href="https://en.wikipedia.org/wiki/Mathematical_Alphanumeric_Symbols#Latin_letters">𝔄𝔏𝔏 ℭ𝔄𝔓𝔖</a>. This makes include guard different from all other entities thus they don't need additional marks (like underscore at the end).</p>
<p>To guarantee uniqueness, they should be based on the full path in a project's source tree. For example, the file <code>foo/src/bar/baz.h</code> in project <code>foo</code> should have the following guard:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef 𝔉𝔒𝔒_𝔅𝔄ℜ_𝔅𝔄ℨ_ℌ</span></div>
<div class="line"><span class="preprocessor">#define 𝔉𝔒𝔒_𝔅𝔄ℜ_𝔅𝔄ℨ_ℌ</span></div>
<div class="line"> </div>
<div class="line">…</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif  </span><span class="comment">// 𝔉𝔒𝔒_𝔅𝔄ℜ_𝔅𝔄ℨ_ℌ</span></div>
</div><!-- fragment --><h2><a class="anchor" id="File_Names"></a>
File Names</h2>
<p>Filenames follow <a href="https://google.github.io/styleguide/cppguide.html#File_Names">the Google C++ Style Guide</a>. While C++ compilers support Unicode just fine many tools that work with files don't. And, in practice, file names are rarely used in cotext where they need to be distinguished from type names or variable names.</p>
<h2><a class="anchor" id="Type_Names"></a>
Type Names</h2>
<p>Type names are using <a href="https://en.wikipedia.org/wiki/Bold">𝐦𝐚𝐭𝐡 𝐛𝐨𝐥𝐝</a>, all lowercase, with underscores between words (<a href="https://en.wikipedia.org/wiki/Snake_case">𝐬𝐧𝐚𝐤𝐞_𝐜𝐚𝐬𝐞</a>).</p>
<div class="fragment"><div class="line"><span class="comment">// classes and structs</span></div>
<div class="line"><span class="keyword">class </span>𝐜𝐨𝐝𝐞_𝐛𝐥𝐨𝐜𝐤 { … };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// using aliases</span></div>
<div class="line"><span class="keyword">using</span> 𝐜𝐨𝐝𝐞_𝐦𝐚𝐩 = std::map&lt;𝐚𝐝𝐝𝐫𝐞𝐬𝐬, 𝐜𝐨𝐝𝐞_𝐛𝐥𝐨𝐜𝐤&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// enums</span></div>
<div class="line"><span class="keyword">enum class</span> 𝐞𝐫𝐫𝐨𝐫_𝐥𝐢𝐬𝐭 { … };</div>
</div><!-- fragment --><h2><a class="anchor" id="Variable_Names"></a>
Variable Names</h2>
<p>The names of variables (including function parameters) and struct data members are all lowercase, with underscores between words (<a href="https://en.wikipedia.org/wiki/Snake_case">snake_case</a>).</p>
<h3><a class="anchor" id="Common_Variable_Names"></a>
Common Variable Names</h3>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="comment">// Use 𝔜𝔄ℭ𝔈 𝐜𝐡𝐚𝐫 instead of char or char8_t</span></div>
<div class="line"><a class="code" href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#a1cc09f1fbc1ac66cd1292650dbc075d3">𝐜𝐡𝐚𝐫</a> field_delimiter;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use std::map directly.</span></div>
<div class="line">std::map&lt;𝐬𝐢𝐳𝐞, 𝐚𝐫𝐞𝐧𝐚_𝐛𝐥𝐨𝐜𝐤&gt; arena_block_map;</div>
<div class="ttc" id="anamespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2_html_a1cc09f1fbc1ac66cd1292650dbc075d3"><div class="ttname"><a href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#a1cc09f1fbc1ac66cd1292650dbc075d3">𝘆𝗮𝗰𝗲::𝐜𝐡𝐚𝐫</a></div><div class="ttdeci">unsigned char 𝐜𝐡𝐚𝐫</div><div class="ttdef"><b>Definition:</b> types.h:29</div></div>
</div><!-- fragment --><h3><a class="anchor" id="Struct_Data_Member_Names"></a>
Struct Data Members Names</h3>
<p>Data members of structs, both static and non-static, are named like ordinary nonmember variables.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>𝐥𝐢𝐛𝐫𝐚𝐫𝐲_𝐩𝐫𝐨𝐩𝐞𝐫𝐭𝐢𝐞𝐬 {</div>
<div class="line">  <a class="code" href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#ae73bd94769612b43551089f498c0ba12">𝐬𝐭𝐫𝐢𝐧𝐠</a> library_name;</div>
<div class="line">  <a class="code" href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#a72d7f47c591b5bd07be00cc846cf82de">𝐬𝐢𝐳𝐞</a> code_size;</div>
<div class="line">  <a class="code" href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#a72d7f47c591b5bd07be00cc846cf82de">𝐬𝐢𝐳𝐞</a> data_size;</div>
<div class="line">};</div>
<div class="ttc" id="anamespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2_html_a72d7f47c591b5bd07be00cc846cf82de"><div class="ttname"><a href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#a72d7f47c591b5bd07be00cc846cf82de">𝘆𝗮𝗰𝗲::𝐬𝐢𝐳𝐞</a></div><div class="ttdeci">std::size_t 𝐬𝐢𝐳𝐞</div><div class="ttdef"><b>Definition:</b> types.h:58</div></div>
<div class="ttc" id="anamespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2_html_ae73bd94769612b43551089f498c0ba12"><div class="ttname"><a href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#ae73bd94769612b43551089f498c0ba12">𝘆𝗮𝗰𝗲::𝐬𝐭𝐫𝐢𝐧𝐠</a></div><div class="ttdeci">std::basic_string&lt; 𝐜𝐡𝐚𝐫 &gt; 𝐬𝐭𝐫𝐢𝐧𝐠</div><div class="ttdef"><b>Definition:</b> types.h:30</div></div>
</div><!-- fragment --><h3><a class="anchor" id="Class_Data_Members_Names"></a>
Class Data Members Names</h3>
<p>Calss data members are using names similar to regular variables and struct data members, but use <a href="https://en.wikipedia.org/wiki/Sans-serif">𝗌𝖺𝗇𝗌-𝗌𝖾𝗋𝗂𝖿</a> <a href="https://en.wikipedia.org/wiki/Mathematical_Alphanumeric_Symbols#Latin_letters">𝗆𝖺𝗍𝗁</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>𝐟𝐨𝐫𝐞𝐢𝐠𝐧_𝐥𝐢𝐛𝐫𝐚𝐫𝐲 {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  …</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  𝐚𝐫𝐜𝐡𝐢𝐭𝐞𝐜𝐭𝐮𝐫𝐞 𝖺𝗋𝖼𝗁𝗂𝗍𝖾𝖼𝗍𝗎𝗋𝖾;</div>
<div class="line">  𝐬𝐲𝐦𝐛𝐨𝐥𝐬_𝐭𝐚𝐛𝐥𝐞&amp; 𝗌𝗒𝗆𝖻𝗈𝗅𝗌_𝗍𝖺𝖻𝗅𝖾;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="Constant_Names"></a>
Constant Names</h2>
<p>Variables declared constexpr or const, and whose value is fixed for the duration of the program, are named, like most entities, use lowercase text with underscores between words (<a href="https://en.wikipedia.org/wiki/Snake_case">𝔰𝔫𝔞𝔨𝔢_𝔠𝔞𝔰𝔢</a>), but <a href="https://en.wikipedia.org/wiki/Fraktur">fraktur-style</a> <a href="https://en.wikipedia.org/wiki/Mathematical_Alphanumeric_Symbols#Latin_letters">𝔩𝔞𝔱𝔦𝔫 𝔩𝔢𝔱𝔱𝔢𝔯𝔰</a>.</p>
<p>For example:</p>
<div class="fragment"><div class="line">constexpr <a class="code" href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#acc4c815c9afe87934661c4377f9f9652">𝐢𝐧𝐭₈</a> 𝔡𝔞𝔶𝔰_𝔦𝔫_𝔞_𝔴𝔢𝔢𝔨 = 7;</div>
<div class="line"><span class="keyword">const</span> 𝔖𝔖𝔈4_𝔰𝔲𝔭𝔭𝔬𝔯𝔱𝔢𝔡 = is_SSE4_supported();  <span class="comment">// Function uses CPUID to determine if SSE4 is available.</span></div>
<div class="ttc" id="anamespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2_html_acc4c815c9afe87934661c4377f9f9652"><div class="ttname"><a href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#acc4c815c9afe87934661c4377f9f9652">𝘆𝗮𝗰𝗲::𝐢𝐧𝐭₈</a></div><div class="ttdeci">std::int8_t 𝐢𝐧𝐭₈</div><div class="ttdef"><b>Definition:</b> types.h:35</div></div>
</div><!-- fragment --><p>All such <code>constexpr</code> variables and variables with static storage duration (i.e., statics and globals, see <a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">Storage Duration</a> for details) should be named this way.</p>
<p>Note that you can only initialize such constants in the runtime if <a href="https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables">no aspect of the program depends on the sequencing of this initialization with respect to all other initializations</a> (except for initializations of objects in the same file). That is: you can not use 𝔖𝔖𝔈4_𝔰𝔲𝔭𝔭𝔬𝔯𝔱𝔢𝔡 to initialize any other global variables declared in <b>other</b> <code>.cc</code> files — but you <b>may</b> use them to initialize <b>other</b> <code>const</code> variables in the <b>same</b> file.</p>
<p>This is because in C++ <a href="https://en.cppreference.com/w/cpp/language/initialization#Dynamic_initialization">ordered dynamic initialization</a> is only guaranteed for members of a single translation unit.</p>
<p>This convention is optional for variables of other storage classes, e.g., automatic variables, otherwise the usual variable naming rules apply.</p>
<h2><a class="anchor" id="Function_Names"></a>
Function Names</h2>
<p>Regular functions are named like variables.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> emit₈(<a class="code" href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#acc4c815c9afe87934661c4377f9f9652">𝐢𝐧𝐭₈</a> value);</div>
<div class="line"><span class="keywordtype">void</span> emit₁₆(<a class="code" href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#a5248aa1792b8a9b4a25908f8416808d1">𝐢𝐧𝐭₁₆</a> value);</div>
<div class="line"><span class="keywordtype">void</span> load_library(<a class="code" href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#ad09da68720587e536d43c337258c75f7">𝐬𝐭𝐫𝐢𝐧𝐠_𝐯𝐢𝐞𝐰</a> name);</div>
<div class="ttc" id="anamespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2_html_a5248aa1792b8a9b4a25908f8416808d1"><div class="ttname"><a href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#a5248aa1792b8a9b4a25908f8416808d1">𝘆𝗮𝗰𝗲::𝐢𝐧𝐭₁₆</a></div><div class="ttdeci">std::int16_t 𝐢𝐧𝐭₁₆</div><div class="ttdef"><b>Definition:</b> types.h:39</div></div>
<div class="ttc" id="anamespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2_html_ad09da68720587e536d43c337258c75f7"><div class="ttname"><a href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#ad09da68720587e536d43c337258c75f7">𝘆𝗮𝗰𝗲::𝐬𝐭𝐫𝐢𝐧𝐠_𝐯𝐢𝐞𝐰</a></div><div class="ttdeci">std::basic_string_view&lt; 𝐜𝐡𝐚𝐫 &gt; 𝐬𝐭𝐫𝐢𝐧𝐠_𝐯𝐢𝐞𝐰</div><div class="ttdef"><b>Definition:</b> types.h:31</div></div>
</div><!-- fragment --><p>This is probably the biggest difference between our approach and <a href="https://google.github.io/styleguide/cppguide.html#Function_Names">rules of the Google C++ Style Guide</a> — but these rules were invented in era before C++11 and lamdas and even then — they include many exceptions when functions should be named like variables or when variables are supposed to be named like functions. We just don't feel that distinction between different callable entities is important enough to make all these rules with exceptions and exceptions from exceptions.</p>
<h2><a class="anchor" id="Template_Names"></a>
Template Names</h2>
<p>Templates are named similar to the same non-template entities, but using <a href="https://en.wikipedia.org/wiki/Italic_type">italic</a> — <a href="https://en.wikipedia.org/wiki/Mathematical_Alphanumeric_Symbols#Latin_letters">𝑟𝑒𝑔𝑢𝑙𝑎𝑟 𝑖𝑡𝑎𝑙𝑖𝑐</a> for <a href="https://en.cppreference.com/w/cpp/language/function_template">function templates</a>, <a href="https://en.wikipedia.org/wiki/Mathematical_Alphanumeric_Symbols#Latin_letters">𝒎𝒂𝒕𝒉 𝒊𝒕𝒂𝒍𝒊𝒄</a> for <a href="https://en.cppreference.com/w/cpp/language/class_template">class templates</a> and <a href="https://en.cppreference.com/w/cpp/language/type_alias">alias templates</a>, and <a href="https://en.wikipedia.org/wiki/Fraktur">𝔣𝔯𝔞𝔨𝔱𝔲𝔯-𝔰𝔱𝔶𝔩𝔢</a> <a href="https://en.wikipedia.org/wiki/Mathematical_Alphanumeric_Symbols#Latin_letters">𝔩𝔞𝔱𝔦𝔫 𝔩𝔢𝔱𝔱𝔢𝔯𝔰</a> for constant <a href="https://en.cppreference.com/w/cpp/language/variable_template">variable templates</a> (i.e. they are named like constants, not like templates). Note: variable templates are only allowed as objects with static storage duration in C++17 — and mutable such variables are <a href="https://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables">forbidden by the Google C++ Style Guide</a>.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;𝐬𝐢𝐳𝐞 𝓽𝓪𝓫𝓵𝓮_𝓼𝓲𝔃𝓮, 𝐬𝐢𝐳𝐞 𝓵𝓲𝓷𝓮_𝓼𝓲𝔃𝓮, <span class="keyword">typename</span> 𝓬𝓱𝓪𝓻 = 𝐜𝐡𝐚𝐫&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#a8921ae8ea09f5c2e2ed6accb2b6b9a2e">𝒔𝒉𝒐𝒓𝒕_𝒔𝒕𝒓𝒊𝒏𝒈_𝒕𝒂𝒃𝒍𝒆</a> final {</div>
<div class="line">  …</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> 𝓽𝓾𝓹𝓵𝓮&gt;</div>
<div class="line">constexpr <span class="keyword">auto</span> <a class="code" href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#a033a70a65326e4dee0109cd88f02612a">𝑡𝑜_𝑎𝑟𝑟𝑎𝑦</a>(𝓽𝓾𝓹𝓵𝓮&amp;&amp; tuple) {</div>
<div class="line">  …</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2_html_a033a70a65326e4dee0109cd88f02612a"><div class="ttname"><a href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#a033a70a65326e4dee0109cd88f02612a">𝘆𝗮𝗰𝗲::𝑡𝑜_𝑎𝑟𝑟𝑎𝑦</a></div><div class="ttdeci">constexpr 𝖞𝖆𝖈𝖊_𝖋𝖔𝖗𝖈𝖊𝖎𝖓𝖑𝖎𝖓𝖊 auto 𝑡𝑜_𝑎𝑟𝑟𝑎𝑦(𝓽𝓾𝓹𝓵𝓮 &amp;&amp;tuple)</div><div class="ttdef"><b>Definition:</b> algorithm.h:44</div></div>
<div class="ttc" id="anamespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2_html_a8921ae8ea09f5c2e2ed6accb2b6b9a2e"><div class="ttname"><a href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#a8921ae8ea09f5c2e2ed6accb2b6b9a2e">𝘆𝗮𝗰𝗲::𝒔𝒉𝒐𝒓𝒕_𝒔𝒕𝒓𝒊𝒏𝒈_𝒕𝒂𝒃𝒍𝒆</a></div><div class="ttdeci">𝒔𝒉𝒐𝒓𝒕_𝒔𝒕𝒓𝒊𝒏𝒈_𝒕𝒂𝒃𝒍𝒆(const 𝓬𝓱𝓪𝓻(&amp;... string)[𝓼𝓽𝓻𝓲𝓷𝓰_𝓼𝓲𝔃𝓮]) -&gt; 𝒔𝒉𝒐𝒓𝒕_𝒔𝒕𝒓𝒊𝒏𝒈_𝒕𝒂𝒃𝒍𝒆&lt; sizeof...(string), std::max({𝓼𝓽𝓻𝓲𝓷𝓰_𝓼𝓲𝔃𝓮...}), 𝓬𝓱𝓪𝓻 &gt;</div></div>
</div><!-- fragment --><p>Note that template parameters are named, using, as usual, all lowercase, with underscores between words (<a href="https://en.wikipedia.org/wiki/Snake_case">𝓼𝓷𝓪𝓴𝓮_𝓬𝓪𝓼𝓮</a>), but <a href="https://en.wikipedia.org/wiki/Cursive">bold script</a> <a href="https://en.wikipedia.org/wiki/Mathematical_Alphanumeric_Symbols#Latin_letters">𝓵𝓪𝓽𝓲𝓷 𝓵𝓮𝓽𝓽𝓮𝓻𝓼</a>. You can also use names 𝓣 or 𝓯 for very short template definitions.</p>
<p>This is another difference from <a href="https://google.github.io/styleguide/cppguide.html#General_Naming_Rules">rules of the Google C++ Style Guide</a> where “template parameters should follow the naming style for their category”.</p>
<h2><a class="anchor" id="Namespace_Names"></a>
Namespace Names</h2>
<p>Namespace names are all lowercase, with underscores between words (<a href="https://en.wikipedia.org/wiki/Snake_case">𝘀𝗻𝗮𝗸𝗲_𝗰𝗮𝘀𝗲</a>), the same most other entities use. They areall nested in the <a class="el" href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html">𝘆𝗮𝗰𝗲</a> namespace and use <a href="https://en.wikipedia.org/wiki/Bold">𝐛𝐨𝐥𝐝</a> <a href="https://en.wikipedia.org/wiki/Sans-serif">𝗌𝖺𝗇𝗌-𝗌𝖾𝗋𝗂𝖿</a> <a href="https://en.wikipedia.org/wiki/Mathematical_Alphanumeric_Symbols#Latin_letters">𝗺𝗮𝘁𝗵 𝗹𝗮𝘁𝗶𝗻 𝗹𝗲𝘁𝘁𝗲𝗿𝘀</a>. This makes them unique and reduce chance of collisions. Nonetheless - collisions are still possible and hard to resolve (as described <a href="https://abseil.io/tips/130">here</a> thus we use fully-qualified names to reference entities in the “sibling namespaces” — but it's Ok to use short names to access entities in the nested, “implementation details” namespaces without starting with <a class="el" href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html">𝘆𝗮𝗰𝗲</a></p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>𝘆𝗮𝗰𝗲::𝗹𝗼𝗴𝗴𝗲𝗿 {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>𝗱𝗲𝘁𝗮𝗶𝗹𝘀 {</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">class </span>𝐨𝐩𝐭𝐢𝐨𝐧𝐬 {</div>
<div class="line">    …</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace 𝗱𝗲𝘁𝗮𝗶𝗹𝘀</span></div>
<div class="line"> </div>
<div class="line">…</div>
<div class="line"> </div>
<div class="line">::𝘆𝗮𝗰𝗲::𝐨𝐩𝐭𝐢𝐨𝐧𝐬 global_options;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Note: not 𝘁𝗿𝗮𝗰𝗲𝗿::𝐨𝐩𝐭𝐢𝐨𝐧𝐬 ! And not even 𝘆𝗮𝗰𝗲::𝘁𝗿𝗮𝗰𝗲𝗿::𝐨𝐩𝐭𝐢𝐨𝐧𝐬, always specify full name.</span></div>
<div class="line">::𝘆𝗮𝗰𝗲::𝘁𝗿𝗮𝗰𝗲𝗿::𝐨𝐩𝐭𝐢𝐨𝐧𝐬 tracer_option;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Note: ::𝘆𝗮𝗰𝗲::𝗹𝗼𝗴𝗴𝗲𝗿::𝗱𝗲𝘁𝗮𝗶𝗹𝘀::𝐨𝐩𝐭𝐢𝐨𝐧𝐬 is not recommended: much longer and looks like “foreign” type.</span></div>
<div class="line">𝗱𝗲𝘁𝗮𝗶𝗹𝘀::𝐨𝐩𝐭𝐢𝐨𝐧𝐬 detailed options;  </div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace 𝘆𝗮𝗰𝗲::𝗹𝗼𝗴𝗴𝗲𝗿</span></div>
</div><!-- fragment --><h2><a class="anchor" id="Enumerator_Names"></a>
Enumerator Names</h2>
<p>Enumerators (for both scoped and unscoped enums) should be named like <a href="#Constant_Names">constants</a>, not like <a href="#Macro_Names">macros</a>. That is, use 𝔢𝔫𝔲𝔪_𝔫𝔞𝔪𝔢 not 𝖞𝖆𝖈𝖊_𝖊𝖓𝖚𝖒_𝖓𝖆𝖒𝖊.</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> 𝐯𝐞𝐫𝐛𝐨𝐬𝐢𝐭𝐲 {</div>
<div class="line">  𝔫𝔬𝔫𝔢,</div>
<div class="line">  𝔩𝔬𝔴,</div>
<div class="line">  𝔪𝔢𝔡𝔦𝔲𝔪,</div>
<div class="line">  𝔥𝔦𝔤𝔥</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="Macro_Names"></a>
Macro Names</h2>
<p>𝔜𝔄ℭ𝔈 doesn't try to pretend that macroses are not useful and don't try to avoid their use “by any means possible”, but since macro names don't obey namespaces we try to avoid name clashes by using <a href="https://en.wikipedia.org/wiki/Bold">bold</a> <a href="https://en.wikipedia.org/wiki/Fraktur">fraktur-style</a> <a href="https://en.wikipedia.org/wiki/Mathematical_Alphanumeric_Symbols#Latin_letters">𝖑𝖆𝖙𝖎𝖓 𝖑𝖊𝖙𝖙𝖊𝖗𝖘</a>, all lowercase, with underscores between words (<a href="https://en.wikipedia.org/wiki/Snake_case">𝖘𝖓𝖆𝖐𝖊_𝖈𝖆𝖘𝖊</a>). Names of <b>global</b> macroses have to be world-unique thus we additionally use 𝖞𝖆𝖈𝖊_ prefix for them.</p>
<p>What do we mean by “global” and “local” macroses?</p>
<p>Some macroses are defined to be used by other modules in header files. And some are used locally. Like this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define 𝖉𝖊𝖋𝖎𝖓𝖊_𝖘𝖑𝖔𝖙_𝖓𝖆𝖒𝖊(𝔁) 𝖞𝖆𝖈𝖊_𝖚𝟴(slot ## x)</span></div>
<div class="line"><span class="keyword">inline</span> constexpr <a class="code" href="namespace_xF0_x9D_x98_x86_xF0_x9D_x97_xAE_xF0_x9D_x97_xB0_xF0_x9D_x97_xB2.html#a8921ae8ea09f5c2e2ed6accb2b6b9a2e">𝒔𝒉𝒐𝒓𝒕_𝒔𝒕𝒓𝒊𝒏𝒈_𝒕𝒂𝒃𝒍𝒆</a>{<a class="code" href="defines_8h.html#a4d36a3090eda242d70bebfb78cadabea">𝖞𝖆𝖈𝖊_𝖉𝖊𝖋𝖎𝖓𝖊_𝖑𝖎𝖘𝖙</a>(𝖉𝖊𝖋𝖎𝖓𝖊_𝖘𝖑𝖔𝖙_𝖓𝖆𝖒𝖊, x, y, z, t)};</div>
<div class="line"><span class="preprocessor">#undef 𝖉𝖊𝖋𝖎𝖓𝖊_𝖘𝖑𝖔𝖙_𝖓𝖆𝖒𝖊</span></div>
<div class="ttc" id="adefines_8h_html_a4d36a3090eda242d70bebfb78cadabea"><div class="ttname"><a href="defines_8h.html#a4d36a3090eda242d70bebfb78cadabea">𝖞𝖆𝖈𝖊_𝖉𝖊𝖋𝖎𝖓𝖊_𝖑𝖎𝖘𝖙</a></div><div class="ttdeci">#define 𝖞𝖆𝖈𝖊_𝖉𝖊𝖋𝖎𝖓𝖊_𝖑𝖎𝖘𝖙(𝓭𝓮𝓯𝓲𝓷𝓮𝓻,...)</div><div class="ttdef"><b>Definition:</b> defines.h:57</div></div>
</div><!-- fragment --><p>If your macro doesn't “leak” into other modules (that is: you don't used <code>#include</code> with it defined and do <code>#undef</code> before header is closed), then it's Ok to use short names and abbreviations for brevity (similarly to local variables).</p>
<p>If your macro may be visible outside of your header — then it's global macro and you need long, descriptive, name and prefix 𝖞𝖆𝖈𝖊_ . </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
